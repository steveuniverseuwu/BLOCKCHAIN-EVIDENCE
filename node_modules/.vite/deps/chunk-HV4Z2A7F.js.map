{
  "version": 3,
  "sources": ["../../multiformats/src/bytes.ts"],
  "sourcesContent": ["export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n"],
  "mappings": ";AAAO,IAAM,QAAQ,IAAI,WAAW,CAAC;AAW/B,SAAU,OAAQ,IAAgB,IAAc;AACpD,MAAI,OAAO,IAAI;AAAE,WAAO;EAAK;AAC7B,MAAI,GAAG,eAAe,GAAG,YAAY;AACnC,WAAO;EACT;AAEA,WAAS,KAAK,GAAG,KAAK,GAAG,YAAY,MAAM;AACzC,QAAI,GAAG,EAAE,MAAM,GAAG,EAAE,GAAG;AACrB,aAAO;IACT;EACF;AAEA,SAAO;AACT;AAEM,SAAU,OAAQ,GAA6C;AACnE,MAAI,aAAa,cAAc,EAAE,YAAY,SAAS,cAAc;AAAE,WAAO;EAAE;AAC/E,MAAI,aAAa,aAAa;AAAE,WAAO,IAAI,WAAW,CAAC;EAAE;AACzD,MAAI,YAAY,OAAO,CAAC,GAAG;AACzB,WAAO,IAAI,WAAW,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU;EAC5D;AACA,QAAM,IAAI,MAAM,mCAAmC;AACrD;",
  "names": []
}
