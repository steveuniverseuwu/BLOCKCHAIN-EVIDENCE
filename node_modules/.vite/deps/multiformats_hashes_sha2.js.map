{
  "version": 3,
  "sources": ["../../multiformats/src/hashes/hasher.ts", "../../multiformats/src/hashes/sha2-browser.ts"],
  "sourcesContent": ["import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n"],
  "mappings": ";;;;;;;AAKA,IAAM,4BAA4B;AAqB5B,SAAU,KAAiD,EAAE,MAAM,MAAM,QAAQ,iBAAiB,gBAAe,GAA0B;AAC/I,SAAO,IAAI,OAAO,MAAM,MAAM,QAAQ,iBAAiB,eAAe;AACxE;AAoBM,IAAO,SAAP,MAAa;EACR;EACA;EACA;EACA;EACA;EAET,YAAa,MAAY,MAAY,QAAkD,iBAA0B,iBAAwB;AACvI,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,kBAAkB,mBAAmB;AAC1C,SAAK,kBAAkB;EACzB;EAEA,OAAQ,OAAmB,SAAuB;AAChD,QAAI,SAAS,YAAY,MAAM;AAC7B,UAAI,QAAQ,WAAW,KAAK,iBAAiB;AAC3C,cAAM,IAAI,MAAM,6DAA6D,KAAK,eAAe,EAAE;MACrG;AAEA,UAAI,KAAK,mBAAmB,QAAQ,QAAQ,WAAW,KAAK,iBAAiB;AAC3E,cAAM,IAAI,MAAM,0DAA0D,KAAK,eAAe,EAAE;MAClG;IACF;AAEA,QAAI,iBAAiB,YAAY;AAC/B,YAAM,SAAS,KAAK,OAAO,KAAK;AAEhC,UAAI,kBAAkB,YAAY;AAChC,eAAO,aAAa,QAAQ,KAAK,MAAM,SAAS,QAAQ;MAC1D;AAEA,aAAO,OAAO,KAAK,YAAU,aAAa,QAAQ,KAAK,MAAM,SAAS,QAAQ,CAAC;IACjF,OAAO;AACL,YAAM,MAAM,mCAAmC;IAEjD;EACF;;AAOF,SAAS,aAAoC,QAAoB,MAAY,UAAiB;AAC5F,MAAI,YAAY,QAAQ,aAAa,OAAO,YAAY;AACtD,QAAI,WAAW,OAAO,YAAY;AAChC,YAAM,IAAI,MAAM,0DAA0D,OAAO,UAAU,EAAE;IAC/F;AAEA,aAAS,OAAO,SAAS,GAAG,QAAQ;EACtC;AAEA,SAAc,OAAO,MAAM,MAAM;AACnC;;;ACnGA,SAAS,IAAK,MAAyB;AACrC,SAAO,OAAM,SAAQ,IAAI,WAAW,MAAM,OAAO,OAAO,OAAO,MAAM,IAAI,CAAC;AAC5E;AAEO,IAAM,SAAS,KAAK;EACzB,MAAM;EACN,MAAM;EACN,QAAQ,IAAI,SAAS;CACtB;AAEM,IAAM,SAAS,KAAK;EACzB,MAAM;EACN,MAAM;EACN,QAAQ,IAAI,SAAS;CACtB;",
  "names": []
}
